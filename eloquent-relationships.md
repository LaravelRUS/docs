# Laravel 8 · Eloquent · Отношения

- [Введение](#introduction)
- [Определение отношений](#defining-relationships)
    - [Один к одному](#one-to-one)
    - [Один ко многим](#one-to-many)
    - [Определение обратной связи Один ко многим](#one-to-many-inverse)
    - [Один через отношение](#has-one-through)
    - [Многие через отношение](#has-many-through)
- [Отношения Многие ко многим](#many-to-many)
    - [Получение столбцов сводной таблицы](#retrieving-intermediate-table-columns)
    - [Фильтрация запросов по столбцам сводной таблицы](#filtering-queries-via-intermediate-table-columns)
    - [Определение пользовательских моделей сводных таблиц](#defining-custom-intermediate-table-models)
- [Полиморфные отношения](#polymorphic-relationships)
    - [Один к одному (полиморфное)](#one-to-one-polymorphic-relations)
    - [Один ко многим (полиморфное)](#one-to-many-polymorphic-relations)
    - [Многие ко многим (полиморфное)](#many-to-many-polymorphic-relations)
    - [Именование полиморфных типов](#custom-polymorphic-types)
- [Динамические отношения](#dynamic-relationships)
- [Запросы отношений](#querying-relations)
    - [Методы отношений против динамических свойств](#relationship-methods-vs-dynamic-properties)
    - [Запрос наличия отношений](#querying-relationship-existence)
    - [Запрос отсутствия отношений](#querying-relationship-absence)
    - [Запрос полиморфных отношений Morph To](#querying-morph-to-relationships)
- [Агрегирование связанных моделей](#aggregating-related-models)
    - [Подсчет связанных моделей](#counting-related-models)
    - [Другие агрегатные функции](#other-aggregate-functions)
    - [Подсчет связанных моделей отношений Morph To](#counting-related-models-on-morph-to-relationships)
- [Нетерпеливая загрузка](#eager-loading)
    - [Ограничение нетерпеливой загрузки](#constraining-eager-loads)
    - [Нетерпеливая пост-загрузка](#lazy-eager-loading)
- [Вставка и обновление связанных моделей](#inserting-and-updating-related-models)
    - [Метод Save](#the-save-method)
    - [Метод Create](#the-create-method)
    - [Обновление отношений Один К](#updating-belongs-to-relationships)
    - [Обновление отношений Многие ко многим](#updating-many-to-many-relationships)
- [Затрагивание временных меток родителя](#touching-parent-timestamps)

<a name="introduction"></a>
## Введение

Таблицы базы данных часто связаны друг с другом. Например, пост в блоге может содержать много комментариев или заказ может быть связан с пользователем, который его разместил. Eloquent упрощает управление этими отношениями и работу с ними, а также поддерживает множество общих отношений:

<!-- <div class="content-list" markdown="1"> -->
- [Один к одному](#one-to-one)
- [Один ко многим](#one-to-many)
- [Многие ко многим](#many-to-many)
- [Один через отношение](#has-one-through)
- [Многие через отношение](#has-many-through)
- [Один к одному (полиморфное)](#one-to-one-polymorphic-relations)
- [Один ко многим (полиморфное)](#one-to-many-polymorphic-relations)
- [Многие ко многим (полиморфное)](#many-to-many-polymorphic-relations)
<!-- </div> -->

<a name="defining-relationships"></a>
## Определение отношений

Отношения Eloquent определяются как методы в классах модели Eloquent. Поскольку отношения также служат мощными [построителями запросов](queries), определение отношений как методов обеспечивает возможность создания цепочек методов и запросов. Например, мы можем связать дополнительные ограничения запроса на эту связь `posts`:

    $user->posts()->where('active', 1)->get();

Но, прежде чем углубляться в использование отношений, давайте узнаем, как определить каждый тип отношений, поддерживаемый Eloquent.

<a name="one-to-one"></a>
### Один к одному

Отношения «один-к-одному» – это очень простой тип отношений базы данных. Например, модель `User` может быть связана с одной моделью `Phone`. Чтобы определить это отношение, мы поместим метод `phone` в модель `User`. Метод `phone` должен вызывать метод `hasOne` и возвращать его результат. Метод `hasOne` доступен для вашей модели через базовый класс `Illuminate\Database\Eloquent\Model` модели:

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;

    class User extends Model
    {
        /**
         * Получить телефон, связанный с пользователем.
         */
        public function phone()
        {
            return $this->hasOne(Phone::class);
        }
    }

Первым аргументом, передаваемым методу `hasOne`, является имя связанного класса модели. Как только связь определена, мы можем получить связанную запись, используя динамические свойства Eloquent. Динамические свойства позволяют получить доступ к методам отношений, как если бы они были свойствами, определенными в модели:

    $phone = User::find(1)->phone;

Eloquent определяет внешний ключ отношения на основе имени родительской модели. В этом случае автоматически предполагается, что модель `Phone` имеет внешний ключ `user_id`. Если вы хотите переопределить это соглашение, вы можете передать второй аргумент методу `hasOne`:

    return $this->hasOne(Phone::class, 'foreign_key');

Кроме того, Eloquent предполагает, что внешний ключ должен иметь значение, соответствующее столбцу первичного ключа родительского элемента. Другими словами, Eloquent будет искать значение столбца `id` пользователя в столбце `user_id` записи `Phone`. Если вы хотите, чтобы отношение использовало значение первичного ключа, отличное от `id` или свойства вашей модели `$primaryKey`, вы можете передать третий аргумент методу `hasOne`:

    return $this->hasOne(Phone::class, 'foreign_key', 'local_key');

<a name="one-to-one-defining-the-inverse-of-the-relationship"></a>
#### Определение обратной связи Один к одному

Итак, мы можем получить доступ к модели `Phone` из нашей модели `User`. Затем давайте определим отношение в модели `Phone`, которое позволит нам получить доступ к пользователю, которому принадлежит телефон. Мы можем определить инверсию отношения `hasOne` с помощью метода `belongsTo`:

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;

    class Phone extends Model
    {
        /**
         * Получить пользователя, владеющего телефоном.
         */
        public function user()
        {
            return $this->belongsTo(User::class);
        }
    }

При вызове метода `user`, Eloquent попытается найти модель `User`, у которой есть `id`, который соответствует столбцу `user_id` в модели `Phone`.

Eloquent определяет имя внешнего ключа, анализируя имя метода отношения и добавляя к имени метода суффикс `_id`. Итак, в этом случае Eloquent предполагает, что модель `Phone` имеет столбец `user_id`. Однако, если внешний ключ в модели `Phone` не является `user_id`, вы можете передать собственное имя ключа в качестве второго аргумента методу `belongsTo`:

    /**
     * Получить пользователя, владеющего телефоном.
     */
    public function user()
    {
        return $this->belongsTo(User::class, 'foreign_key');
    }

Если родительская модель не использует `id` в качестве первичного ключа или вы хотите найти связанную модель, используя другой столбец, вы можете передать третий аргумент методу `belongsTo`, указав ваш ключ родительской таблицы:

    /**
     * Получить пользователя, владеющего телефоном.
     */
    public function user()
    {
        return $this->belongsTo(User::class, 'foreign_key', 'owner_key');
    }

<a name="one-to-many"></a>
### Один ко многим

Отношение «один-ко-многим» используется для определения отношений, в которых одна модель является родительской для одной или нескольких дочерних моделей. Например, пост в блоге может содержать бесконечное количество комментариев. Как и все другие отношения Eloquent, отношения «один-ко-многим» определяются путем определения метода в вашей модели Eloquent:

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;

    class Post extends Model
    {
        /**
         * Получить комментарии к посту блога.
         */
        public function comments()
        {
            return $this->hasMany(Comment::class);
        }
    }

Помните, что Eloquent автоматически определит правильный столбец внешнего ключа для модели `Comment`. По соглашению Eloquent берет имя родительской модели в «змеином регистре» и добавляет к нему суффикс `_id`. Итак, в этом примере Eloquent предполагает, что столбец внешнего ключа в модели `Comment` именуется `post_id`.

Как только метод отношения определен, мы можем получить доступ к [коллекции](eloquent-collections) связанных комментариев, используя свойство `comments`. Поскольку Eloquent обеспечивает «динамические свойства отношений», то мы можем получить доступ к методам отношений, как если бы они были определены как свойства в модели:

    use App\Models\Post;

    $comments = Post::find(1)->comments;

    foreach ($comments as $comment) {
        //
    }

Поскольку все отношения также служат в качестве построителей запросов, вы можете добавить дополнительные ограничения в запрос отношения, вызвав метод `comments` и продолжая связывать условия с запросом:

    $comment = Post::find(1)->comments()
                        ->where('title', 'foo')
                        ->first();

Подобно методу `hasOne`, вы также можете переопределить внешние и локальные ключи, передав дополнительные аргументы методу `hasMany`:

    return $this->hasMany(Comment::class, 'foreign_key');

    return $this->hasMany(Comment::class, 'foreign_key', 'local_key');

<a name="one-to-many-inverse"></a>
#### Определение обратной связи Один ко многим

Теперь, когда мы можем получить доступ ко всем комментариям поста, давайте определим отношение, чтобы разрешить комментарию доступ к его родительскому посту. Чтобы определить инверсию отношения `hasMany`, определите метод отношения в дочерней модели, который вызывает метод `belongsTo`:

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;

    class Comment extends Model
    {
        /**
         * Получить пост, которому принадлежит комментарий.
         */
        public function post()
        {
            return $this->belongsTo(Post::class);
        }
    }

Как только связь определена, мы можем получить родительский пост комментария, обратившись к «динамическому свойству отношения» `post`:

    use App\Models\Comment;

    $comment = Comment::find(1);

    return $comment->post->title;

В приведенном выше примере Eloquent попытается найти модель `Post`, у которой есть `id`, который соответствует столбцу `post_id` в модели `Comment`.

Eloquent определяет имя внешнего ключа по умолчанию, анализируя имя метода отношения и добавляя к имени метода суффикс `_`, за которым следует имя столбца первичного ключа родительской модели. Итак, в этом примере Eloquent предполагает, что внешний ключ модели `Post` в таблице `comments` – это `post_id`.

Однако, если внешний ключ для ваших отношений не соответствует этим соглашениям, вы можете передать свое имя внешнего ключа в качестве второго аргумента методу `belongsTo`:

    /**
     * Получить пост, которому принадлежит комментарий.
     */
    public function post()
    {
        return $this->belongsTo(Post::class, 'foreign_key');
    }

Если ваша родительская модель не использует `id` в качестве первичного ключа или вы хотите найти связанную модель, используя другой столбец, то вы можете передать третий аргумент методу `belongsTo`, указав свой ключ родительской таблицы:

    /**
     * Получить пост, которому принадлежит комментарий.
     */
    public function post()
    {
        return $this->belongsTo(Post::class, 'foreign_key', 'owner_key');
    }

<a name="default-models"></a>
### Модели по умолчанию

Отношения `belongsTo`, `hasOne`, `hasOneThrough` и `morphOne` позволяют вам определить модель по умолчанию, которая будет возвращена, если данное отношение равно `null`. Этот шаблон часто называют [шаблоном нулевого объекта](https://en.wikipedia.org/wiki/Null_Object_pattern), который поможет удалить условные проверки в вашем коде. В следующем примере отношение `user` вернет пустую модель `App\Models\User`, если к модели `Post` не привязан ни один `user`:

    /**
     * Получить автора поста.
     */
    public function user()
    {
        return $this->belongsTo(User::class)->withDefault();
    }

Чтобы заполнить модель по умолчанию атрибутами, вы можете передать массив или замыкание методу `withDefault`:

    /**
     * Получить автора поста.
     */
    public function user()
    {
        return $this->belongsTo(User::class)->withDefault([
            'name' => 'Guest Author',
        ]);
    }

    /**
     * Получить автора поста.
     */
    public function user()
    {
        return $this->belongsTo(User::class)->withDefault(function ($user, $post) {
            $user->name = 'Guest Author';
        });
    }

<a name="has-one-through"></a>
### Один через отношение

Отношение «один-через-отношение» определяет отношение «один-к-одному» с другой моделью. Однако, это отношение указывает на то, что декларируемую модель можно сопоставить с одним экземпляром другой модели, связавшись _через_ третью модель.

Например, в приложении автомастерской каждая модель `Mechanic` может быть связана с одной моделью `Car`, и каждая модель `Car` может быть связана с одной моделью `Owner`. В то время как механик и владелец не имеют прямых отношений в базе данных, механик может получить доступ к владельцу _через_ модель `Car`. Давайте посмотрим на таблицы, необходимые для определения этой связи:

    mechanics
        id - integer
        name - string

    cars
        id - integer
        model - string
        mechanic_id - integer

    owners
        id - integer
        name - string
        car_id - integer

Теперь, когда мы изучили структуру таблицы для отношения, давайте определим отношения в модели `Mechanic`:

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;

    class Mechanic extends Model
    {
        /**
         * Получить владельца машины.
         */
        public function carOwner()
        {
            return $this->hasOneThrough(Owner::class, Car::class);
        }
    }

Первый аргумент, передаваемый методу `hasOneThrough` – это имя последней модели, к которой мы хотим получить доступ, а второй аргумент – это имя промежуточной (сводной) модели.

<a name="has-one-through-key-conventions"></a>
#### Соглашения по именованию ключей отношения Один через отношение

Типичные соглашения о внешнем ключе Eloquent будут использоваться при выполнении запросов отношения. Если вы хотите изменить ключи отношения, вы можете передать их в качестве третьего и четвертого аргументов методу `hasOneThrough`. Третий аргумент – это имя внешнего ключа сводной модели. Четвертый аргумент – это имя внешнего ключа окончательной модели. Пятый аргумент – это локальный ключ, а шестой аргумент – это локальный ключ сводной модели:

    class Mechanic extends Model
    {
        /**
         * Получить владельца машины.
         */
        public function carOwner()
        {
            return $this->hasOneThrough(
                Owner::class,
                Car::class,
                'mechanic_id', // Внешний ключ в таблице `cars` ...
                'car_id', // Внешний ключ в таблице `owners` ...
                'id', // Локальный ключ в таблице `mechanics` ...
                'id' // Локальный ключ в таблице `cars` ...
            );
        }
    }

<a name="has-many-through"></a>
### Многие через отношение

Отношение «многие-через-отношение» обеспечивает удобный способ доступа к отдаленным отношениям через промежуточное отношение. Например, предположим, что мы создаем платформу развертывания, такую как [Laravel Vapor](https://vapor.laravel.com). Модель `Project` может получить доступ ко многим моделям `Deployment` через сводную модель `Environment`. Используя этот пример, вы можете легко собрать все развертывания для конкретной среды. Давайте посмотрим на таблицы, необходимые для определения этой связи:

    projects
        id - integer
        name - string

    environments
        id - integer
        project_id - integer
        name - string

    deployments
        id - integer
        environment_id - integer
        commit_hash - string

Теперь, когда мы изучили структуру таблицы для отношения, давайте определим отношение в модели `Project`:

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;

    class Project extends Model
    {
        /**
         * Получить все развертывания для проекта.
         */
        public function deployments()
        {
            return $this->hasManyThrough(Deployment::class, Environment::class);
        }
    }

Первый аргумент, передаваемый методу `hasManyThrough` – это имя последней модели, к которой мы хотим получить доступ, а второй аргумент – это имя сводной модели.

Хотя таблица модели `Deployment` не содержит столбца `project_id`, отношение `hasManyThrough` обеспечивает доступ к `deployments` проекта через `$project->deployments`. Чтобы получить эти модели, Eloquent проверяет столбец `project_id` в сводной таблице модели `Environment`. После нахождения соответствующих идентификаторов `environments` они используются для запроса таблицы модели `Deployment`.

<a name="has-many-through-key-conventions"></a>
#### Соглашения по именованию ключей отношения Многие через отношение

Типичные соглашения о внешнем ключе Eloquent будут использоваться при выполнении запросов отношения. Если вы хотите изменить ключи отношения, вы можете передать их в качестве третьего и четвертого аргументов методу `hasManyThrough`. Третий аргумент – это имя внешнего ключа сводной модели. Четвертый аргумент – это имя внешнего ключа окончательной модели. Пятый аргумент – это локальный ключ, а шестой аргумент – это локальный ключ сводной модели:

    class Project extends Model
    {
        public function deployments()
        {
            return $this->hasManyThrough(
                Deployment::class,
                Environment::class,
                'project_id', // Внешний ключ в таблице `environments` ...
                'environment_id', // Внешний ключ в таблице `deployments` ...
                'id', // Локальный ключ в таблице `projects` ...
                'id' // Локальный ключ в таблице `environments` ...
            );
        }
    }

<a name="many-to-many"></a>
## Отношения Многие ко многим

Отношения «многие-ко-многим» немного сложнее, чем отношения `hasOne` и `hasMany`. Примером отношения «многие-ко-многим» является пользователь, у которого много ролей, и эти роли также используются другими пользователями в приложении. Например, пользователю могут быть назначены роли «Автор» и «Редактор»; однако эти роли также могут быть назначены другим пользователям. Итак, у пользователя много ролей, а у роли много пользователей.

<a name="many-to-many-table-structure"></a>
#### Структура таблицы Многие ко многим

Чтобы определить эту связь, необходимы три таблицы базы данных: `users`, `roles`, и `role_user`. Таблица `role_user` является производной от имен связанных моделей в алфавитном порядке и содержит столбцы `user_id` и `role_id`. Эта таблица используется как промежуточная таблица, связывающая пользователей и роли.

Помните, поскольку роль может принадлежать многим пользователям, мы не можем просто разместить столбец `user_id` в таблице `role`. Это означало бы, что роль могла принадлежать только одному пользователю. Для обеспечения поддержки ролей, назначаемых нескольким пользователям, необходима таблица `role_user`. Мы можем резюмировать структуру таблицы отношений следующим образом:

    users
        id - integer
        name - string

    roles
        id - integer
        name - string

    role_user
        user_id - integer
        role_id - integer

<a name="many-to-many-model-structure"></a>
#### Структура модели Многие ко многим

Отношения «многие-ко-многим» определяются путем написания метода, который возвращает результат метода `belongsToMany`. Метод `belongsToMany` обеспечен базовым классом `Illuminate\Database\Eloquent\Model`, который используется всеми моделями Eloquent вашего приложения. Например, давайте определим метод `roles` в нашей модели `User`. Первым аргументом, передаваемым этому методу, является имя класса сводной модели:

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;

    class User extends Model
    {
        /**
         * Роли, принадлежащие пользователю.
         */
        public function roles()
        {
            return $this->belongsToMany(Role::class);
        }
    }

Как только связь определена, вы можете получить доступ к ролям пользователя, используя динамическое свойство связи `roles`:

    use App\Models\User;

    $user = User::find(1);

    foreach ($user->roles as $role) {
        //
    }

Поскольку все отношения также служат в качестве построителей запросов, вы можете добавить дополнительные ограничения к запросу отношений, вызвав метод `roles` и продолжив связывать условия с запросом:

    $roles = User::find(1)->roles()->orderBy('name')->get();

Чтобы определить имя промежуточной таблицы отношения, Eloquent соединит имена двух связанных моделей в алфавитном порядке. Однако вы можете изменить это соглашение. Вы можете сделать это, передав второй аргумент методу `belongsToMany`:

    return $this->belongsToMany(Role::class, 'role_user');

В дополнение к переопределению имени промежуточной таблицы, вы также можете изменить имена столбцов ключей в таблице, передав дополнительные аргументы методу `belongsToMany`. Третий аргумент – это имя внешнего ключа модели, для которой вы определяете отношение, а четвертый аргумент – это имя внешнего ключа модели, к которой вы присоединяетесь:

    return $this->belongsToMany(Role::class, 'role_user', 'user_id', 'role_id');

<a name="many-to-many-defining-the-inverse-of-the-relationship"></a>
#### Определение обратной связи Многие ко многим

Чтобы определить «обратное» отношение «многие-ко-многим», вы должны определить метод в связанной модели, который также возвращает результат метода `belongsToMany`. Чтобы завершить наш пример пользователи / роли, давайте определим метод `users` в модели `Role`:

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;

    class Role extends Model
    {
        /**
         * Пользователи, принадлежащие к роли.
         */
        public function users()
        {
            return $this->belongsToMany(User::class);
        }
    }

Как видите, отношение определяется точно так же, как и его аналог в модели `User`, за исключением ссылки на модель `App\Models\User`. Поскольку мы повторно используем метод `belongsToMany`, все стандартные параметры настройки таблиц и ключей доступны при определении «обратных» отношений «многие-ко-многим».

<a name="retrieving-intermediate-table-columns"></a>
### Получение столбцов сводной таблицы

Как вы уже узнали, для работы с отношениями «многие-ко-многим» требуется наличие промежуточной таблицы. Eloquent предлагает несколько очень полезных способов взаимодействия с этой таблицей. Например, предположим, что наша модель `User` имеет много моделей `Role`, с которыми она связана. После доступа к этой связи мы можем получить доступ к промежуточной таблице с помощью атрибута `pivot` в моделях:

    use App\Models\User;

    $user = User::find(1);

    foreach ($user->roles as $role) {
        echo $role->pivot->created_at;
    }

Обратите внимание, что каждой модели `Role`, которую мы получаем, автоматически назначается атрибут `pivot`. Этот атрибут содержит модель, представляющую промежуточную таблицу.

По умолчанию в модели `pivot` будут присутствовать только ключи модели. Если ваша промежуточная таблица содержит дополнительные атрибуты, вы должны указать их при определении отношения:

    return $this->belongsToMany(Role::class)->withPivot('active', 'created_by');

Если вы хотите, чтобы ваша промежуточная таблица имела временные метки `created_at` и `updated_at`, которые автоматически поддерживаются Eloquent, вызовите метод `withTimestamps` при определении отношения:

    return $this->belongsToMany(Role::class)->withTimestamps();

> {note} Промежуточные таблицы, использующие автоматически поддерживаемые временные метки Eloquent, должны иметь столбцы временных меток `created_at` и `updated_at`.

<a name="customizing-the-pivot-attribute-name"></a>
#### Корректировка имени атрибута `pivot`

Как отмечалось ранее, атрибуты из промежуточной таблицы могут быть доступны в моделях через атрибут `pivot`. Однако, вы можете изменить имя этого атрибута, чтобы лучше отразить его назначение в вашем приложении.

Например, если ваше приложение содержит пользователей, которые могут подписаться на подкасты, вы, вероятно, имеете отношение «многие-ко-многим» между пользователями и подкастами. По желанию можно переименовать атрибут `pivot` промежуточной таблицы на `subscription`. Это можно сделать с помощью метода `as` при определении отношения:

    return $this->belongsToMany(Podcast::class)
                    ->as('subscription')
                    ->withTimestamps();

После указания атрибута промежуточной таблицы, вы можете получить доступ к данным промежуточной таблицы, используя указанное имя:

    $users = User::with('podcasts')->get();

    foreach ($users->flatMap->podcasts as $podcast) {
        echo $podcast->subscription->created_at;
    }

<a name="filtering-queries-via-intermediate-table-columns"></a>
### Фильтрация запросов по столбцам сводной таблицы

Вы также можете отфильтровать результаты, возвращаемые запросами отношения `belongsToMany`, используя методы `wherePivot`, `wherePivotIn`, и `wherePivotNotIn` при определении отношения:

    return $this->belongsToMany(Role::class)
                    ->wherePivot('approved', 1);

    return $this->belongsToMany(Role::class)
                    ->wherePivotIn('priority', [1, 2]);

    return $this->belongsToMany(Role::class)
                    ->wherePivotNotIn('priority', [1, 2]);

<a name="defining-custom-intermediate-table-models"></a>
### Определение пользовательских моделей сводных таблиц

Если вы хотите определить собственную модель промежуточной таблицы отношения «многие-ко-многим», то вы можете вызвать метод `using` при определении отношения. Явные сводные модели дают вам возможность определять дополнительные методы в сводной модели.

Явные сводные модели отношения «многие-ко-многим» должны расширять класс `Illuminate\Database\Eloquent\Relations\Pivot`, в то время как явные полиморфные сводные модели отношения «многие-ко-многим» должны расширять класс `Illuminate\Database\Eloquent\Relations\MorphPivot`. Например, мы можем определить модель `Role`, которая использует явную сводную модель `RoleUser`:

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;

    class Role extends Model
    {
        /**
         * Пользователи, принадлежащие к роли.
         */
        public function users()
        {
            return $this->belongsToMany(User::class)->using(RoleUser::class);
        }
    }

При определении модели `RoleUser` вы должны расширять класс `Illuminate\Database\Eloquent\Relations\Pivot`:

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Relations\Pivot;

    class RoleUser extends Pivot
    {
        //
    }

> {note} Сводные модели не могут использовать трейт `SoftDeletes`. Если вам нужно программно удалить сводные записи, подумайте о преобразовании вашей сводной модели в реальную модель Eloquent.

<a name="custom-pivot-models-and-incrementing-ids"></a>
#### Пользовательские сводные модели и автоинкрементные идентификаторы

Если вы определили отношение «многие-ко-многим», которое использует явную сводную модель, и эта сводная модель имеет автоинкрементный первичный ключ, то вы должны убедиться, что ваш класс явной сводной модели определяет свойство `$incrementing`, для которого установлено значение` true `.

    /**
     * Указывает, что идентификаторы модели являются автоинкрементными.
     *
     * @var bool
     */
    public $incrementing = true;

<a name="polymorphic-relationships"></a>
## Полиморфные отношения

Полиморфные отношения позволяют дочерней модели принадлежать более чем к одному типу модели с использованием одной ассоциации. Например, представьте, что вы создаете приложение, которое позволяет пользователям делиться постами и видео в блогах. В таком приложении модель `Comment` может принадлежать как к моделям `Post`, так и к `Video`.

<a name="one-to-one-polymorphic-relations"></a>
### Один к одному (полиморфное)

<a name="one-to-one-polymorphic-table-structure"></a>
#### Структура таблицы отношения Один к одному (полиморфное)

Полиморфное отношение «один-к-одному» похоже на типичное «один-к-одному» отношение; однако, дочерняя модель может принадлежать более чем к одному типу моделей с помощью одной ассоциации. Например, блог `Post` и `User` могут иметь полиморфное отношение С моделью `Image`. Использование полиморфного «один-к-одному» отношения позволяет вам иметь единую таблицу уникальных изображений, которые могут быть связаны с постами и пользователями. Сначала рассмотрим структуру таблицы:

    posts
        id - integer
        name - string

    users
        id - integer
        name - string

    images
        id - integer
        url - string
        imageable_id - integer
        imageable_type - string

Обратите внимание на столбцы `imageable_id` и `imageable_type` в таблице `images`. Столбец `imageable_id` будет содержать значение идентификатора поста или пользователя, а столбец `imageable_type` будет содержать имя класса родительской модели. Столбец `imageable_type` используется Eloquent для определения того, какой «тип» родительской модели возвращать при доступе к отношению `imageable`. В этом случае столбец будет содержать либо `App\Models\Post`, либо `App\Models\User`.

<a name="one-to-one-polymorphic-model-structure"></a>
#### Структура модели отношения Один к одному (полиморфное)

Давайте рассмотрим определения модели, необходимые для построения этой связи:

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;

    class Image extends Model
    {
        /**
         * Получить родительскую модель (пользователя или поста), к которой относится изображение.
         */
        public function imageable()
        {
            return $this->morphTo();
        }
    }

    class Post extends Model
    {
        /**
         * Получить изображение поста.
         */
        public function image()
        {
            return $this->morphOne(Image::class, 'imageable');
        }
    }

    class User extends Model
    {
        /**
         * Получить изображение пользователя.
         */
        public function image()
        {
            return $this->morphOne(Image::class, 'imageable');
        }
    }

<a name="one-to-one-polymorphic-retrieving-the-relationship"></a>
#### Получение отношения Один к одному (полиморфное)

Как только ваша таблица базы данных и модели определены, вы можете получить доступ к отношениям через свои модели. Например, чтобы получить изображение для поста, мы можем обратиться к динамическому свойству связи `image`:

    use App\Models\Post;

    $post = Post::find(1);

    $image = $post->image;

Вы можете получить родительский объект полиморфной модели, обратившись к имени метода, который выполняет вызов `morphTo`. В данном случае это метод `imageable` модели `Image`. Итак, мы будем обращаться к этому методу как к динамическому свойству отношения:

    use App\Models\Image;

    $image = Image::find(1);

    $imageable = $image->imageable;

Отношение `imageable` в модели `Image` будет возвращать экземпляр `Post` или `User`, в зависимости от того, к какому типу модели относится изображение.

<a name="morph-one-to-one-key-conventions"></a>
#### Соглашения по именованию ключей отношения Один к одному (полиморфное)

Если необходимо, то вы можете указать имя столбцов `id` и `type`, используемых вашей полиморфной дочерней моделью. Если вы это сделаете, то убедитесь, что вы всегда передаете имя отношения в качестве первого аргумента методу `morphTo`. Обычно это значение должно совпадать с именем метода, поэтому вы можете использовать константу `__FUNCTION__` PHP:

    /**
     * Получить родительскую модель, к которой относится изображение.
     */
    public function imageable()
    {
        return $this->morphTo(__FUNCTION__, 'imageable_type', 'imageable_id');
    }

<a name="one-to-many-polymorphic-relations"></a>
### Один ко многим (полиморфное)

<a name="one-to-many-polymorphic-table-structure"></a>
#### Структура таблицы отношения Один ко многим (полиморфное)

Полиморфное отношение «один-ко-многим» похоже на типичное отношение «один-ко-многим»; однако, дочерняя модель может принадлежать более чем к одному типу моделей с помощью одной ассоциации. Например, представьте, что пользователи вашего приложения могут «комментировать» посты и видео. Используя полиморфные отношения, вы можете использовать одну таблицу `comments`, чтобы хранить комментарии как для постов, так и для видео. Во-первых, давайте рассмотрим структуру таблицы, необходимую для построения этой связи:

    posts
        id - integer
        title - string
        body - text

    videos
        id - integer
        title - string
        url - string

    comments
        id - integer
        body - text
        commentable_id - integer
        commentable_type - string

<a name="one-to-many-polymorphic-model-structure"></a>
#### Структура модели отношения Один ко многим (полиморфное)

Давайте рассмотрим определения модели, необходимые для построения этой связи:

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;

    class Comment extends Model
    {
        /**
         * Получить родительскую модель (поста или видео), к которой относится комментарий.
         */
        public function commentable()
        {
            return $this->morphTo();
        }
    }

    class Post extends Model
    {
        /**
         * Получить все комментарии поста.
         */
        public function comments()
        {
            return $this->morphMany(Comment::class, 'commentable');
        }
    }

    class Video extends Model
    {
        /**
         * Получить все комментарии видео.
         */
        public function comments()
        {
            return $this->morphMany(Comment::class, 'commentable');
        }
    }

<a name="one-to-many-polymorphic-retrieving-the-relationship"></a>
#### Получение отношения Один ко многим (полиморфное)

После того, как ваша таблица базы данных и модели определены, вы можете получить доступ к отношениям через динамические свойства отношений вашей модели. Например, чтобы получить доступ ко всем комментариям к постам, мы можем использовать динамическое свойство `comments`:

    use App\Models\Post;

    $post = Post::find(1);

    foreach ($post->comments as $comment) {
        //
    }

Вы также можете получить родительскую модель полиморфной дочерней модели, обратившись к имени метода, который выполняет вызов `morphTo`. В данном случае это метод `commentable` в модели `Comment`. Итак, мы будем обращаться к этому методу как к динамическому свойству связи, чтобы получить доступ к родительской модели комментария:

    use App\Models\Comment;

    $comment = Comment::find(1);

    $commentable = $comment->commentable;

Отношение `commentable` в модели `Comment` вернет либо экземпляр `Post`, либо `Video`, в зависимости от того, какой тип модели является родительским для комментария.

<a name="many-to-many-polymorphic-relations"></a>
### Многие ко многим (полиморфное)

<a name="many-to-many-polymorphic-table-structure"></a>
#### Структура таблицы отношения Многие ко многим (полиморфное)

Полиморфные отношения «многие-ко-многим» немного сложнее, чем полиморфные отношения «один-к-одному» и «один-ко-многим». Например, модель `Post` и модель `Video` могут иметь полиморфное отношение к модели `Tag`. Использование полиморфного отношения «многие-ко-многим» в этой ситуации позволит вашему приложению иметь единую таблицу уникальных тегов, которые могут быть связаны с постами или видео. Во-первых, давайте рассмотрим структуру таблицы, необходимую для построения этой связи:

    posts
        id - integer
        name - string

    videos
        id - integer
        name - string

    tags
        id - integer
        name - string

    taggables
        tag_id - integer
        taggable_id - integer
        taggable_type - string

> {tip} Прежде чем погрузиться в полиморфные отношения «многие-ко-многим», вам может быть полезно прочитать документацию по типичным [отношениям «многие-ко-многим»](#many-to-many).

<a name="many-to-many-polymorphic-model-structure"></a>
#### Структура модели отношения Многие ко многим (полиморфное)

Далее, мы готовы определить отношения в моделях. Обе модели `Post` и `Video` будут содержать метод `tags`, который вызывает метод `morphToMany`, предоставляемый базовым классом модели Eloquent.

Метод `morphToMany` принимает имя связанной модели, а также «имя отношения». В зависимости от имени, которое мы присвоили имени нашей промежуточной таблицы и содержащихся в ней ключей, мы будем называть эту связь `taggable`:

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;

    class Post extends Model
    {
        /**
         * Получить все теги поста.
         */
        public function tags()
        {
            return $this->morphToMany(Tag::class, 'taggable');
        }
    }

<a name="many-to-many-polymorphic-defining-the-inverse-of-the-relationship"></a>
#### Определение обратной связи Многие ко многим (полиморфное)

Затем в модели `Tag` вы должны определить метод для каждой из ее возможных родительских моделей. Итак, в этом примере мы определим метод `posts` и метод `videos`. Оба эти метода должны возвращать результат метода `morphedByMany`.

Метод `morphedByMany` принимает имя связанной модели, а также «имя отношения». В зависимости от имени, которое мы присвоили имени нашей промежуточной таблицы и содержащихся в ней ключей, мы будем называть эту связь `taggable`:

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;

    class Tag extends Model
    {
        /**
         * Получить все посты, которым присвоен этот тег.
         */
        public function posts()
        {
            return $this->morphedByMany(Post::class, 'taggable');
        }

        /**
         * Получить все видео, которым присвоен этот тег.
         */
        public function videos()
        {
            return $this->morphedByMany(Video::class, 'taggable');
        }
    }

<a name="many-to-many-polymorphic-retrieving-the-relationship"></a>
#### Получение отношения Многие ко многим (полиморфное)

Как только ваша таблица базы данных и модели определены, вы можете получить доступ к отношениям через свои модели. Например, чтобы получить доступ ко всем тегам для публикации, вы можете использовать динамическое свойство связи `tags`:

    use App\Models\Post;

    $post = Post::find(1);

    foreach ($post->tags as $tag) {
        //
    }

Вы можете получить родительскую модель полиморфного отношения из полиморфной дочерней модели, обратившись к имени метода, который выполняет вызов `morphedByMany`. В данном случае это методы `posts` или `videos` в модели `Tag`:

    use App\Models\Tag;

    $tag = Tag::find(1);

    foreach ($tag->posts as $post) {
        //
    }

    foreach ($tag->videos as $video) {
        //
    }

<a name="custom-polymorphic-types"></a>
### Именование полиморфных типов

По умолчанию Laravel будет использовать полное имя класса для хранения «типа» связанной модели. Например, учитывая приведенный выше пример отношения «один-ко-многим», где модель `Comment` может принадлежать модели `Post` или `Video`, по умолчанию `commentable_type` будет либо `App\Models\Post`, либо `App\Models\Video`, соответственно. По желанию можно отделить эти значения от внутренней структуры вашего приложения.

Например, вместо использования названий моделей в качестве «типа» мы можем использовать простые строки, такие как `post` и `video`. Таким образом, значения столбца полиморфного «типа» в нашей базе данных останутся действительными, даже если модели будут переименованы:

    use Illuminate\Database\Eloquent\Relations\Relation;

    Relation::morphMap([
        'post' => 'App\Models\Post',
        'video' => 'App\Models\Video',
    ]);

Вы можете зарегистрировать `morphMap` в методе `boot` вашего класса `App\Providers\AppServiceProvider` или создать отдельного поставщика службы, если хотите.

Вы можете определить псевдоним полиморфного типа конкретной модели во время выполнения, используя метод модели `getMorphClass`. И наоборот, вы можете определить полное имя класса, связанное с псевдонимом полиморфного типа, используя метод `Relation::getMorphedModel`:

    use Illuminate\Database\Eloquent\Relations\Relation;

    $alias = $post->getMorphClass();

    $class = Relation::getMorphedModel($alias);

> {note} При добавлении «карты полиморфных типов» в существующее приложение каждое значение столбца `*_type` в вашей базе данных, которое все еще содержит полностью определенный класс, необходимо преобразовать в его псевдоним, указанный в «карте полиморфных типов».

<a name="dynamic-relationships"></a>
## Динамические отношения

Вы можете использовать метод `resolveRelationUsing` для определения отношений между моделями Eloquent во время выполнения скрипта. Хотя обычно это не рекомендуется для нормальной разработки приложений, но иногда это может быть полезно при разработке пакетов Laravel.

Метод `resolveRelationUsing` принимает желаемое имя отношения в качестве своего первого аргумента. Второй аргумент, передаваемый методу, должен быть замыканием, которое принимает экземпляр модели и возвращает допустимое определение отношения Eloquent. Как правило, вы должны настроить динамические отношения в методе `boot` [поставщика служб](providers):

    use App\Models\Order;
    use App\Models\Customer;

    Order::resolveRelationUsing('customer', function ($orderModel) {
        return $orderModel->belongsTo(Customer::class, 'customer_id');
    });

> {note} При определении динамических отношений всегда предоставляйте явные аргументы имени ключа методам связи Eloquent.

<a name="querying-relations"></a>
## Запросы отношений

Поскольку все отношения Eloquent определяются с помощью методов, вы можете вызывать эти методы для получения экземпляра отношения, не выполняя фактического запроса для загрузки связанных моделей. Кроме того, все типы отношений Eloquent также служат в качестве [построителей запросов](queries), позволяя вам продолжать связывать ограничения в запросе отношений, прежде чем окончательно выполнить запрос SQL к вашей базе данных.

Например, представьте себе приложение для блога, в котором модель `User` имеет множество связанных моделей `Post`:

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;

    class User extends Model
    {
        /**
         * Получить все посты пользователя.
         */
        public function posts()
        {
            return $this->hasMany(Post::class);
        }
    }

Вы можете запросить отношение `posts` и добавить к ним дополнительные ограничения к отношениям, например:

    use App\Models\User;

    $user = User::find(1);

    $user->posts()->where('active', 1)->get();

Вы можете использовать любой из методов [построителя запросов](queries) Laravel для отношения, поэтому обязательно изучите документацию по построителю запросов, чтобы узнать обо всех доступных вам методах.

<a name="chaining-orwhere-clauses-after-relationships"></a>
#### Создание цепочки выражений `orWhere` после отношений

Как показано в приведенном выше примере, вы можете добавлять дополнительные ограничения к отношениям при их запросе. Однако, будьте осторожны при создании цепочек выражений `orWhere` с отношением, поскольку предложения `orWhere` будут логически сгруппированы на том же уровне, что и ограничение отношения:

    $user->posts()
            ->where('active', 1)
            ->orWhere('votes', '>=', 100)
            ->get();

В приведенном выше примере будет сгенерирован следующий SQL. Как видите, выражение `or` предписывает запросу возвращать _любого_ пользователя с более чем 100 голосами. Запрос больше не ограничен конкретным пользователем:

```sql
select *
from posts
where user_id = ? and active = 1 or votes >= 100
```

В большинстве ситуаций следует использовать [логические группы](queries.md#logical-grouping) для группировки условий в круглые скобки:

    use Illuminate\Database\Eloquent\Builder;

    $user->posts()
            ->where(function (Builder $query) {
                return $query->where('active', 1)
                             ->orWhere('votes', '>=', 100);
            })
            ->get();

В приведенном выше примере будет получен следующий SQL. Обратите внимание, что логическая группировка правильно сгруппировала ограничения, и запрос остается ограниченным для конкретного пользователя:

```sql
select *
from posts
where user_id = ? and (active = 1 or votes >= 100)
```

<a name="relationship-methods-vs-dynamic-properties"></a>
### Методы отношений против динамических свойств

Если вам не нужно добавлять дополнительные ограничения в запрос отношения Eloquent, вы можете получить доступ к отношению, как если бы это было свойство. Например, продолжая использовать наши модели `User` и `Post` из примера, мы можем получить доступ ко всем постам пользователя следующим образом:

    use App\Models\User;

    $user = User::find(1);

    foreach ($user->posts as $post) {
        //
    }

Динамические свойства отношений выполняют «отложенную загрузку», что означает, что они будут загружать данные своих отношений только при фактическом доступе к ним. Из-за этого разработчики часто используют [нетерпеливую загрузку](#eager-loading) для предварительной загрузки отношений, которые, как они знают, будут доступны после загрузки модели. Нетерпеливая загрузка обеспечивает значительное сокращение количества SQL-запросов, которые необходимо выполнить для загрузки отношений модели.

<a name="querying-relationship-existence"></a>
### Запрос наличия отношений

При извлечении записей модели бывает необходимо ограничить результаты в зависимости от наличия связи. Например, представьте, что вы хотите получить все посты блога, содержащие хотя бы один комментарий. Для этого вы можете передать имя отношения методам `has` и `orHas`:

    use App\Models\Post;

    // Получить все посты, в которых есть хотя бы один комментарий ...
    $posts = Post::has('comments')->get();

Вы также можете указать оператор и значение счетчика для уточнения запроса:

    // Получить посты, в которых есть 3 или более комментариев ...
    $posts = Post::has('comments', '>=', 3)->get();

Вы можете использовать «точечную нотацию» для выполнения запроса к вложенным отношениям. Например, вы можете получить все посты, в которых есть хотя бы один комментарий с хотя бы одним изображением:

    // Получить посты, в которых есть хотя бы один комментарий с изображениями ...
    $posts = Post::has('comments.images')->get();

Если вам нужно еще больше возможностей, вы можете использовать методы `whereHas` и `orWhereHas` для определения дополнительных ограничений запроса для ваших `has`-запросов, например, для проверки содержимого комментария:

    use Illuminate\Database\Eloquent\Builder;

    // Получить посты с хотя бы одним комментарием, содержащим `code%` ...
    $posts = Post::whereHas('comments', function (Builder $query) {
        $query->where('content', 'like', 'code%');
    })->get();

    // Получить посты с как минимум десятью комментариями, содержащими `code%` ...
    $posts = Post::whereHas('comments', function (Builder $query) {
        $query->where('content', 'like', 'code%');
    }, '>=', 10)->get();

> {note} Eloquent в настоящее время не поддерживает запросы о существовании отношений между базами данных. Отношения должны существовать в одной базе данных.

<a name="querying-relationship-absence"></a>
### Запрос отсутствия отношений

При извлечении записей модели бывает необходимо ограничить результаты на основании отсутствия связи. Например, представьте, что вы хотите получить все посты блога, которые **не** имеют комментариев. Для этого вы можете передать имя отношения методам `doesntHave` и `orDoesntHave`:

    use App\Models\Post;

    $posts = Post::doesntHave('comments')->get();

Если вам нужно еще больше возможностей, вы можете использовать методы `whereDoesntHave` и `orWhereDoesntHave` для определения дополнительных ограничений запроса для ваших `doesntHave`-запросов, например, для проверки содержимого комментария:

    use Illuminate\Database\Eloquent\Builder;

    $posts = Post::whereDoesntHave('comments', function (Builder $query) {
        $query->where('content', 'like', 'code%');
    })->get();

Вы можете использовать «точечную нотацию» для выполнения запроса к вложенным отношениям. Например, следующий запрос будет извлекать все посты, у которых нет комментариев; однако, посты с комментариями от авторов, которые не забанены, будут включены в результаты:

    use Illuminate\Database\Eloquent\Builder;

    $posts = Post::whereDoesntHave('comments.author', function (Builder $query) {
        $query->where('banned', 0);
    })->get();

<a name="querying-morph-to-relationships"></a>
### Запрос полиморфных отношений Morph To

Чтобы узнать о существовании полиморфных «один-к» отношений, вы можете использовать методы `whereHasMorph` и `whereDoesntHaveMorph`. Эти методы принимают имя отношения в качестве своего первого аргумента. Затем методы принимают имена связанных моделей, которые вы хотите включить в запрос. Наконец, вы можете предоставить замыкание, которое ограничивает запрос отношения:

    use App\Models\Comment;
    use App\Models\Post;
    use App\Models\Video;
    use Illuminate\Database\Eloquent\Builder;

    // Получить комментарии, связанные с постами или видео с заголовком, содержащими `code%` ...
    $comments = Comment::whereHasMorph(
        'commentable',
        [Post::class, Video::class],
        function (Builder $query) {
            $query->where('title', 'like', 'code%');
        }
    )->get();

    // Получить комментарии, связанные с постами с заголовком, не содержащим `code%` ...
    $comments = Comment::whereDoesntHaveMorph(
        'commentable',
        Post::class,
        function (Builder $query) {
            $query->where('title', 'like', 'code%');
        }
    )->get();

Иногда требуется добавить ограничения запроса в зависимости от «типа» связанной полиморфной модели. Замыкание, переданное методу `whereHasMorph`, может получить значение `$type` в качестве второго аргумента. Этот аргумент позволяет вам создавать запрос на основе «типа»:

    use Illuminate\Database\Eloquent\Builder;

    $comments = Comment::whereHasMorph(
        'commentable',
        [Post::class, Video::class],
        function (Builder $query, $type) {
            $column = $type === Post::class ? 'content' : 'title';

            $query->where($column, 'like', 'code%');
        }
    )->get();

<a name="querying-all-morph-to-related-models"></a>
#### Запрос всех связанных моделей

Допускается использование метасимвола подстановки `*` в качестве значения при передачи массива возможных полиморфных моделей. Это проинструктирует Laravel извлечь все возможные полиморфные типы из базы данных. Laravel выполнит дополнительный запрос, чтобы выполнить эту операцию:

    use Illuminate\Database\Eloquent\Builder;

    $comments = Comment::whereHasMorph('commentable', '*', function (Builder $query) {
        $query->where('title', 'like', 'foo%');
    })->get();

<a name="aggregating-related-models"></a>
## Агрегирование связанных моделей

<a name="counting-related-models"></a>
### Подсчет связанных моделей

Иногда требуется подсчитать количество связанных моделей для отношения, не загружая модели. Для этого вы можете использовать метод `withCount`. Метод `withCount` помещает атрибут `{relation}_count` в результирующие модели:

    use App\Models\Post;

    $posts = Post::withCount('comments')->get();

    foreach ($posts as $post) {
        echo $post->comments_count;
    }

Передавая массив методу `withCount`, вы можете добавить «счетчики» для нескольких отношений, а также добавить дополнительные ограничения к запросам:

    use Illuminate\Database\Eloquent\Builder;

    $posts = Post::withCount(['votes', 'comments' => function (Builder $query) {
        $query->where('content', 'like', 'code%');
    }])->get();

    echo $posts[0]->votes_count;
    echo $posts[0]->comments_count;

Вы также можете использовать псевдоним результата подсчета отношений, разрешив несколько подсчетов для одной и той же связи:

    use Illuminate\Database\Eloquent\Builder;

    $posts = Post::withCount([
        'comments',
        'comments as pending_comments_count' => function (Builder $query) {
            $query->where('approved', false);
        },
    ])->get();

    echo $posts[0]->comments_count;
    echo $posts[0]->pending_comments_count;

<a name="deferred-count-loading"></a>
#### Отложенная загрузка подсчета связанных моделей

Используя метод `loadCount`, вы можете загрузить счетчик отношений после того, как родительская модель уже была получена:

    $book = Book::first();

    $book->loadCount('genres');

Если вам нужно установить дополнительные ограничения запроса для запроса подсчета, вы можете передать массив с ключами отношений, которые вы хотите подсчитать. Значения массива должны быть замыканиями, которые получают экземпляр построителя запросов:

    $book->loadCount(['reviews' => function ($query) {
        $query->where('rating', 5);
    }])

<a name="relationship-counting-and-custom-select-statements"></a>
#### Подсчет отношений и пользовательские операторы `SELECT`

Если вы комбинируете `withCount` с оператором `SELECT`, убедитесь, что вы вызываете `withCount` после метода `select`:

    $posts = Post::select(['title', 'body'])
                    ->withCount('comments')
                    ->get();

<a name="other-aggregate-functions"></a>
### Другие агрегатные функции

Помимо метода `withCount`, Eloquent содержит методы `withMin`, `withMax`, `withAvg` и `withSum`. Эти методы добавят атрибут `{relation}_{function}_{column}` в ваши результирующие модели:

    use App\Models\Post;

    $posts = Post::withSum('comments', 'votes')->get();

    foreach ($posts as $post) {
        echo $post->comments_sum_votes;
    }

Как и метод `loadCount`, также доступны отложенные версии этих методов. Эти дополнительные агрегированные операции могут выполняться на уже полученных моделях Eloquent:

    $post = Post::first();

    $post->loadSum('comments', 'votes');

<a name="counting-related-models-on-morph-to-relationships"></a>
### Подсчет связанных моделей отношений Morph To

Если вы хотите загрузить полиморфное отношение «один-к», а также связанные счетчики моделей для различных сущностей, которые могут быть возвращены этим отношением, то вы можете использовать метод `with` в сочетании с отношениями `morphTo` – метод `morphWithCount`.

В этом примере предположим, что модели `Photo` и `Post` могут создавать модели `ActivityFeed`. Предположим, что модель `ActivityFeed` определяет полиморфное отношение «один-к» с именем `parentable`, которое позволяет нам получить родительскую модель `Photo` или `Post` для переданного экземпляра `ActivityFeed`. Кроме того, предположим, что модели `Photo` имеют много моделей `Tag`, а модели `Post` имеют много моделей `Comment`.

Теперь давайте представим, что мы хотим получить экземпляры `ActivityFeed` и загрузить родительские модели для каждого экземпляра `ActivityFeed`. Кроме того, мы хотим получить количество тегов, связанных с каждой родительской фотографией, и количество комментариев, связанных с каждым родительским постом:

    use Illuminate\Database\Eloquent\Relations\MorphTo;

    $activities = ActivityFeed::with([
        'parentable' => function (MorphTo $morphTo) {
            $morphTo->morphWithCount([
                Photo::class => ['tags'],
                Post::class => ['comments'],
            ]);
        }])->get();

<a name="morph-to-deferred-count-loading"></a>
#### Отложенная загрузка подсчета связанных моделей отношений Morph To

Предположим, мы уже получили набор моделей `ActivityFeed` и теперь хотим загрузить счетчики вложенных отношений для различных родительских (`parentable`) моделей, связанных с `ActivityFeed`. Для этого вы можете использовать метод `loadMorphCount`:

    $activities = ActivityFeed::with('parentable')->get();

    $activities->loadMorphCount('parentable', [
        Photo::class => ['tags'],
        Post::class => ['comments'],
    ]);

<a name="eager-loading"></a>
## Нетерпеливая загрузка

При доступе к отношениям Eloquent как к свойствам связанные модели «загружаются отложенно». Это означает, что данные отношения фактически не загружаются, пока вы впервые не получите доступ к свойству. Однако Eloquent может «нетерпеливо загрузить» отношения во время запроса родительской модели. Нетерпеливая загрузка позволяет избежать проблем «N+1» с запросами. Чтобы проиллюстрировать проблему «N+1» запроса, рассмотрим модель `Book`, которая «принадлежит» модели `Author`:

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;

    class Book extends Model
    {
        /**
         * Получить автора книги.
         */
        public function author()
        {
            return $this->belongsTo(Author::class);
        }
    }

Теперь давайте получим все книги и их авторов:

    use App\Models\Book;

    $books = Book::all();

    foreach ($books as $book) {
        echo $book->author->name;
    }

Этот цикл выполнит один запрос для получения всех книг из таблицы базы данных, затем еще один запрос для каждой книги, чтобы получить автора книги. Итак, если у нас есть 25 книг, приведенный выше код будет запускать 26 запросов: один для исходной книги и 25 дополнительных запросов для получения автора каждой книги.

К счастью, мы можем использовать нетерпеливую загрузку, чтобы сократить эту операцию до двух запросов. При построении запроса вы можете указать, какие отношения должны быть загружены с помощью метода `with`:

    $books = Book::with('author')->get();

    foreach ($books as $book) {
        echo $book->author->name;
    }

Для этой операции будут выполнены только два запроса – один запрос для получения всех книг и один запрос – для получения всех авторов для всех книг:

```sql
select * from books

select * from authors where id in (1, 2, 3, 4, 5, ...)
```

<a name="eager-loading-multiple-relationships"></a>
#### Нетерпеливая загрузка множественных отношений

Иногда вам может понадобиться загрузить несколько разных отношений. Для этого просто передайте массив отношений методу `with`:

    $books = Book::with(['author', 'publisher'])->get();

<a name="nested-eager-loading"></a>
#### Вложенная нетерпеливая загрузка

Чтобы нетерпеливо загрузить отношения отношений, вы можете использовать «точечную нотацию». Например, давайте загрузим всех авторов книги и все личные контакты авторов:

    $books = Book::with('author.contacts')->get();

<a name="nested-eager-loading-morphto-relationships"></a>
#### Вложенная нетерпеливая загрузка отношений Morph To

Если вы хотите загрузить полиморфное отношение «один-к», а также вложенные отношения для различных сущностей, которые могут быть возвращены этим отношением, то вы можете использовать метод `with` в сочетании с отношениями `morphTo` – метод `morphWith`. Чтобы проиллюстрировать этот метод, давайте рассмотрим следующую модель:

    <?php

    use Illuminate\Database\Eloquent\Model;

    class ActivityFeed extends Model
    {
        /**
         * Получить родительский элемент записи ленты активности.
         */
        public function parentable()
        {
            return $this->morphTo();
        }
    }

В этом примере предположим, что модели `Event`, `Photo` и `Post` могут создавать модели `ActivityFeed`. Кроме того, предположим, что модели `Event` принадлежат модели `Calendar`, модели `Photo` связаны с моделями `Tag`, а модели `Post` принадлежат модели `Author`.

Используя эти определения моделей и отношения, мы можем получить экземпляры модели `ActivityFeed` и нетерпеливо загрузить все родительские (`parentable`) модели и их соответствующие вложенные отношения:

    use Illuminate\Database\Eloquent\Relations\MorphTo;

    $activities = ActivityFeed::query()
        ->with(['parentable' => function (MorphTo $morphTo) {
            $morphTo->morphWith([
                Event::class => ['calendar'],
                Photo::class => ['tags'],
                Post::class => ['author'],
            ]);
        }])->get();

<a name="eager-loading-specific-columns"></a>
#### Нетерпеливая загрузка определенных столбцов

Вам не всегда может понадобиться каждый столбец из извлекаемых вами отношений. По этой причине Eloquent позволяет вам указать, какие столбцы отношения вы хотите получить:

    $books = Book::with('author:id,name')->get();

> {note} При использовании этого функционала вы всегда должны включать столбец `id` и любые соответствующие столбцы внешнего ключа в список столбцов, которые вы хотите получить.

<a name="eager-loading-by-default"></a>
#### Нетерпеливая загрузка по умолчанию

Иногда требуется постоянная загрузка некоторых отношений при извлечении модели. Для этого вы можете определить свойство `$with` в модели:

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;

    class Book extends Model
    {
        /**
         * Отношения, которые всегда должны быть загружены.
         *
         * @var array
         */
        protected $with = ['author'];

        /**
         * Получить автора книги.
         */
        public function author()
        {
            return $this->belongsTo(Author::class);
        }
    }

Если вы хотите удалить элемент из свойства `$with` для одного запроса, вы можете использовать метод `without`:

    $books = Book::without('author')->get();

<a name="constraining-eager-loads"></a>
### Ограничение нетерпеливой загрузки

Иногда требуется нетерпеливая загрузка отношения с указанием дополнительного условия для запроса нетерпеливой загрузки. Вы можете сделать это, передав массив отношений методу `with`, где ключ массива – это имя отношения, а значение массива – это замыкание, которое добавляет дополнительные ограничения к запросу нетерпеливой загрузки:

    use App\Models\User;

    $users = User::with(['posts' => function ($query) {
        $query->where('title', 'like', '%code%');
    }])->get();

В этом примере Eloquent будет загружать только те посты, столбец `title` которых содержит слово `code`. Вы можете вызвать другие методы [построителя запросов](queries), позволяя вам продолжать связывать ограничения запроса нетерпеливой загрузки:

    $users = User::with(['posts' => function ($query) {
        $query->orderBy('created_at', 'desc');
    }])->get();

> {note} Методы `limit` и` take` построителя запросов нельзя использовать при ограничении нетерпеливой загрузки.

<a name="constraining-eager-loading-of-morph-to-relationships"></a>
#### Ограничение нетерпеливой загрузки отношений Morph To

Если вы хотите нетерпеливо загрузить полиморфное отношение «один-к», Eloquent выполнит несколько запросов для получения каждого типа связанной модели. Вы можете добавить дополнительные ограничения к каждому из этих запросов, используя метод `constrain` полиморфного отношения «один-к»:

    use Illuminate\Database\Eloquent\Builder;
    use Illuminate\Database\Eloquent\Relations\MorphTo;

    $comments = Comment::with(['commentable' => function (MorphTo $morphTo) {
        $morphTo->constrain([
            Post::class => function (Builder $query) {
                $query->whereNull('hidden_at');
            },
            Video::class => function (Builder $query) {
                $query->where('type', 'educational');
            },
        ]);
    }])->get();

В этом примере Eloquent будет загружать только те посты, которые не были скрыты, а видео только с типом как образовательное.

<a name="lazy-eager-loading"></a>
### Нетерпеливая пост-загрузка

Иногда требуется нетерпеливо загрузить отношение только после получения родительской модели. Например, это может быть полезно, если вам нужно динамически решать, загружать ли связанные модели:

    use App\Models\Book;

    $books = Book::all();

    if ($someCondition) {
        $books->load('author', 'publisher');
    }

Если вам нужно задать дополнительные ограничения запроса нетерпеливой загрузки, вы можете передать массив с ключом отношений, которые вы хотите загрузить. Значения массива должны быть экземплярами замыкания, которые получают экземпляр запроса:

    $author->load(['books' => function ($query) {
        $query->orderBy('published_date', 'asc');
    }]);

Чтобы загрузить отношение только в том случае, если оно еще не было загружено, используйте метод `loadMissing`:

    $book->loadMissing('author');

<a name="nested-lazy-eager-loading-morphto"></a>
#### Вложенная нетерпеливая пост-загрузка и отношения Morph To

Если вы хотите нетерпеливо загрузить полиморфное отношение «один-к», а также вложенные отношения для различных сущностей, которые могут быть возвращены этим отношением, вы можете использовать метод `loadMorph`.

Этот метод принимает имя полиморфного отношения «один-к» в качестве своего первого аргумента и массив пар модель / отношение в качестве второго аргумента. Чтобы проиллюстрировать этот метод, давайте рассмотрим следующую модель:

    <?php

    use Illuminate\Database\Eloquent\Model;

    class ActivityFeed extends Model
    {
        /**
         * Получить родительский элемент записи ленты активности.
         */
        public function parentable()
        {
            return $this->morphTo();
        }
    }

В этом примере предположим, что модели `Event`, `Photo` и `Post` могут создавать модели `ActivityFeed`. Кроме того, предположим, что модели `Event` принадлежат модели `Calendar`, модели `Photo` связаны с моделями `Tag`, а модели `Post` принадлежат модели `Author`.

Используя эти определения моделей и отношения, мы можем получить экземпляры модели `ActivityFeed` и нетерпеливо загрузить все родительские (`parentable`) модели и их соответствующие вложенные отношения:

    $activities = ActivityFeed::with('parentable')
        ->get()
        ->loadMorph('parentable', [
            Event::class => ['calendar'],
            Photo::class => ['tags'],
            Post::class => ['author'],
        ]);

<a name="inserting-and-updating-related-models"></a>
## Вставка и обновление связанных моделей

<a name="the-save-method"></a>
### Метод Save

Eloquent содержит удобные методы для добавления новых моделей в отношения. Например, возможно, вам нужно добавить новый комментарий к посту. Вместо того, чтобы вручную задавать атрибут `post_id` в модели `Comment`, вы можете вставить комментарий, используя метод отношения `save`:

    use App\Models\Comment;
    use App\Models\Post;

    $comment = new Comment(['message' => 'A new comment.']);

    $post = Post::find(1);

    $post->comments()->save($comment);

Обратите внимание, что мы не обращались к связи `comments` как к динамическому свойству. Вместо этого мы вызвали метод `comments`, чтобы получить экземпляр отношения. Метод `save` автоматически добавит соответствующее значение `post_id` в новую модель `Comment`.

Если вам нужно сохранить несколько связанных моделей, вы можете использовать метод `saveMany`:

    $post = Post::find(1);

    $post->comments()->saveMany([
        new Comment(['message' => 'A new comment.']),
        new Comment(['message' => 'Another new comment.']),
    ]);

Методы `save` и `saveMany` не будут добавлять новые модели ни в какие отношения, хранимые в памяти, прежде загруженные в родительскую модель. Если вы планируете получить доступ к отношениям после использования методов `save` или `saveMany`, то вы можете использовать метод `refresh` для перезагрузки модели и ее отношений:

    $post->comments()->save($comment);

    $post->refresh();

    // Все комментарии, включая только что сохраненный комментарий ...
    $post->comments;

<a name="the-push-method"></a>
#### Рекурсивное сохранение моделей и отношений

Если вы хотите сохранить вашу модель и все связанные с ней отношения, вы можете использовать метод `push`. В этом примере модель `Post` будет сохранена, а также ее комментарии и авторы этих комментариев:

    $post = Post::find(1);

    $post->comments[0]->message = 'Message';
    $post->comments[0]->author->name = 'Author Name';

    $post->push();

<a name="the-create-method"></a>
### Метод Create

В дополнение к методам `save` и `saveMany` вы также можете использовать метод `create`, который принимает массив атрибутов, создает модель и вставляет ее в базу данных. Разница между `save` и `create` в том, что `save` принимает полный экземпляр модели Eloquent, а `create` принимает простой массив PHP. Вновь созданная модель будет возвращена методом `create`:

    use App\Models\Post;

    $post = Post::find(1);

    $comment = $post->comments()->create([
        'message' => 'A new comment.',
    ]);

Вы можете использовать метод `createMany` для создания нескольких связанных моделей:

    $post = Post::find(1);

    $post->comments()->createMany([
        ['message' => 'A new comment.'],
        ['message' => 'Another new comment.'],
    ]);

Вы также можете использовать методы `findOrNew`, `firstOrNew`, `firstOrCreate`, и `updateOrCreate` для [создания и обновления моделей отношений](eloquent.md#upserts).

> {tip} Перед использованием метода `create` обязательно ознакомьтесь с документацией о [массовом присвоении](eloquent.md#mass-assignment) атрибутов.

<a name="updating-belongs-to-relationships"></a>
### Обновление отношений Один К

Если вы хотите назначить дочернюю модель новой родительской модели, вы можете использовать метод `associate`. В этом примере модель `User` определяет отношение `belongsTo` к модели `Account`. Метод `associate` установит внешний ключ дочерней модели:

    use App\Models\Account;

    $account = Account::find(10);

    $user->account()->associate($account);

    $user->save();

Чтобы удалить родительскую модель из дочерней модели, вы можете использовать метод `dissociate`. Этот метод установит для внешнего ключа отношения значение `null`:

    $user->account()->dissociate();

    $user->save();

<a name="updating-many-to-many-relationships"></a>
### Обновление отношений Многие ко многим

<a name="attaching-detaching"></a>
#### Присоединение / Отсоединение отношений Многие ко многим

Eloquent также содержит методы, которые делают работу с отношениями «многие-ко-многим» более удобной. Например, представим, что у пользователя может быть много ролей, а у роли может быть много пользователей. Вы можете использовать метод `attach`, чтобы присоединить роль к пользователю, вставив запись в промежуточную таблицу отношения:

    use App\Models\User;

    $user = User::find(1);

    $user->roles()->attach($roleId);

При присоединении отношения к модели вы также можете передать массив дополнительных данных для вставки в промежуточную таблицу:

    $user->roles()->attach($roleId, ['expires' => $expires]);

Иногда может потребоваться удалить роль пользователя. Чтобы удалить запись отношения «многие-ко-многим», используйте метод `detach`. Метод `detach` удалит соответствующую запись из промежуточной таблицы; однако обе модели останутся в базе данных:

    // Отсоединяем одну роль от пользователя ...
    $user->roles()->detach($roleId);

    // Отсоединяем от пользователя все роли ...
    $user->roles()->detach();

Для удобства `attach` и `detach` также принимают в качестве входных данных массивы идентификаторов:

    $user = User::find(1);

    $user->roles()->detach([1, 2, 3]);

    $user->roles()->attach([
        1 => ['expires' => $expires],
        2 => ['expires' => $expires],
    ]);

<a name="syncing-associations"></a>
#### Синхронизация ассоциаций отношений Многие ко многим

Вы также можете использовать метод `sync` для построения ассоциаций «многие-ко-многим». Метод `sync` принимает массив идентификаторов для размещения в промежуточной таблице. Любые идентификаторы, которых нет в данном массиве, будут удалены из промежуточной таблицы. Итак, после завершения этой операции в промежуточной таблице будут существовать только идентификаторы из переданного массива:

    $user->roles()->sync([1, 2, 3]);

Вы также можете передать дополнительные значения промежуточной таблицы с идентификаторами:

    $user->roles()->sync([1 => ['expires' => true], 2, 3]);

Если вы не хотите отделять существующие связи, идентификаторы которых отсутствуют в переданном массиве, то вы можете использовать метод `syncWithoutDetaching`:

    $user->roles()->syncWithoutDetaching([1, 2, 3]);

<a name="toggling-associations"></a>
#### Переключение ассоциаций отношений Многие ко многим

Отношение «многие-ко-многим» также содержит метод `toggle`, который «переключает» статус присоединения указанных идентификаторов связанных моделей. Если переданный идентификатор в настоящее время присоединен, он будет отсоединен. Аналогично, если он в настоящее время отсоединен, то он будет присоединен:

    $user->roles()->toggle([1, 2, 3]);

<a name="updating-a-record-on-the-intermediate-table"></a>
#### Обновление записи сводной таблицы отношений Многие ко многим

Если вам нужно обновить существующую строку в промежуточной таблице ваших отношений, то вы можете использовать метод `updateExistingPivot`. Этот метод принимает внешний ключ промежуточной записи и массив атрибутов для обновления:

    $user = User::find(1);

    $user->roles()->updateExistingPivot($roleId, [
        'active' => false,
    ]);

<a name="touching-parent-timestamps"></a>
## Затрагивание временных меток родителя

Когда в модели определены методы `belongsTo` или `belongsToMany` по отношению к другой модели, например `Comment`, который принадлежит `Post`, то иногда бывает необходимо обновить временную метку родителя при обновлении дочерней модели.

Например, когда модель `Comment` обновляется, то вы можете автоматически «затронуть» временную метку `updated_at` родительской модели `Post`, чтобы она была установлена на текущую дату и время. Для этого вы можете добавить свойство `$touches` к дочерней модели, содержащее имена отношений, для которых должны обновляться временные метки `updated_at` при обновлении дочерней модели:

    <?php

    namespace App\Models;

    use Illuminate\Database\Eloquent\Model;

    class Comment extends Model
    {
        /**
         * Все отношения, временные метки которых должны быть затронуты.
         *
         * @var array
         */
        protected $touches = ['post'];

        /**
         * Получить пост, к которому принадлежит комментарий.
         */
        public function post()
        {
            return $this->belongsTo(Post::class);
        }
    }

> {note} Временные метки родительской модели будут обновлены только в том случае, если дочерняя модель обновлена с помощью метода `save` Eloquent.
