git 9b7c044f079bfb583f5ec4d35a42a23b85868570

---

# Формы и HTML

- [Открытие формы](#opening-a-form)
- [Защита от CRSF](#csrf-protection)
- [Привязка модели к форме](#form-model-binding)
- [Метки](#labels)
- [Текстовые и скрытые поля](#text)
- [Чекбоксы и радиокнопки](#checkboxes-and-radio-buttons)
- [Загрузка файлов](#file-input)
- [Выпадающие списки](#drop-down-lists)
- [Кнопки](#buttons)
- [Макросы](#custom-macros)
- [Формирование URL](#generating-urls)

<a name="opening-a-form"></a>
## Открытие формы

#### Открытие формы

	{{ Form::open(array('url' => 'foo/bar')) }}
		//
	{{ Form::close() }}

По умолчанию используется метод `POST`, но вы можете указать другой метод:

	echo Form::open(array('url' => 'foo/bar', 'method' => 'put'))

> **Примечание:** так как HTML-формы поддерживают только методы `POST` и `GET`, методы `PUT` и `DELETE` будут автоматически сэмулированы и переданы в скрытом поле `_method`.

Также вы можете открыть форму, которая может указывать на именованный(-е) маршрут или действие  контроллера:

	echo Form::open(array('route' => 'route.name'))

	echo Form::open(array('action' => 'Controller@method'))

Вы можете передавать им параметры таким образом:

	echo Form::open(array('route' => array('route.name', $user->id)))

	echo Form::open(array('action' => array('Controller@method', $user->id)))

Если ваша форма будет загружать файлы, добавьте опцию `files`:

	echo Form::open(array('url' => 'foo/bar', 'files' => true))

<a name="csrf-protection"></a>
## Защита от CRSF

Laravel предоставляет простую защиту от подделки межсайтовых запросов. Сперва случайная последовательность символов (CSRF токен) помещается в сессию. Не переживайте - это делается автоматически. Эта строка также автоматически будет добавлена в вашу форму в виде скрытого поля. Тем не менее, если вы хотите сгенерировать HTML-код для этого поля, вы можете использовать метод `token`.

#### Добавление CRSF-токена в форму

	echo Form::token();

#### Присоединение CRSF-фильтра к маршруту

	Route::post('profile', array('before' => 'csrf', function()
	{
		//
	}));

<a name="form-model-binding"></a>
## Привязка модели к форме

Зачастую вам надо представить содержимое модели в виде формы. Чтобы сделать это, используйте метод `Form::model`.

#### Открытие формы для модели

	echo Form::model($user, array('route' => array('user.update', $user->id)))

Теперь, когда вы генерируете элемент формы - такой, как текстовое поле - значение свойства модели, соответствующее этому полю, будет присвоено ему автоматически. Так, для примера, значение текстового поля, названного `email`, будет установлено в значение свойства модели пользователя `email`. Но это еще не всё! Если в сессии будет переменная, чьё имя соответствует имени текстового поля, то будет использовано это значение, а не свойство модели.

Итак, приоритет выглядит следующим образом:
1. Flash-переменная сессии ([старый ввод](/docs/{{version}}/requests#old))
2. Напрямую переданные значения в запрос
3. Свойство модели

Это позволяет вам быстро строить формы, которые не только привязаны к свойствам модели, но и легко заполняются повторно, если произошла какая-нибудь ошибка на сервере.

> **Примечание:** при использовании `Form::model` всегда закрывайте форму при помощи метода `Form::close`!

<a name="labels"></a>
## Метки

#### Генерация элемента метки (label)

	echo Form::label('email', 'Адрес e-mail');

#### Передача дополнительных атрибутов для тега

	echo Form::label('email', 'Адрес e-mail', array('class' => 'awesome'));

> **Примечание:** после создания метки, любой элемент формы созданный вами, имя которого соответствует имени метки, автоматически получит её ID.

<a name="text"></a>
## Текстовые и скрытые поля

#### Создание текстового поля ввода

	echo Form::text('username');

#### Указание значения по умолчанию

	echo Form::text('email', 'example@gmail.com');

> **Примечание:** методы *hidden* и *textarea* принимают те же параметры, что и метод *text*.

#### Генерация поля ввода пароля

	echo Form::password('password');
	
#### Генерация других полей

	echo Form::email($name, $value = null, $attributes = array());

	echo Form::file($name, $attributes = array());
	
<a name="checkboxes-and-radio-buttons"></a>
## Чекбоксы и кнопки переключения

#### Генерация чекбокса или кнопки переключения (radio button)

	echo Form::checkbox('name', 'value');
	
	echo Form::radio('name', 'value');

#### Генерация нажатого чекбокса или радиокнопки, выбранной по умолчанию

	echo Form::checkbox('name', 'value', true);
	
	echo Form::radio('name', 'value', true);

<a name="file-input"></a>
## Загрузка файлов

#### Генерация поля загрузки файла

	echo Form::file('image');

> **Примечание:** Для загрузки файлов необходимо, чтобы форма бфла открыта с параметром `'files'=>true`.

<a name="drop-down-lists"></a>
## Выпадающие списки

#### Генерация выпадающего списка

	echo Form::select('size', array('L' => 'Большой', 'S' => 'Маленький'));

#### Генерация списка со значением по умолчанию

	echo Form::select('size', array('L' => 'Большой', 'S' => 'Маленький'), 'S');

#### Генерация списка с группами (optgroup)

	echo Form::select('animal', array(
		'Кошки' => array('leopard' => 'Леопард'),
		'Собаки' => array('spaniel' => 'Спаниель'),
	));

<a name="buttons"></a>
## Кнопки

#### Генерация кнопки отправки формы

	echo Form::submit('Нажми меня!');

> **Примечание:** вам нужно создать кнопку (&lt;button&gt;)? Используйте метод *button* - он принимает те же параметры, что *submit*.

<a name="custom-macros"></a>
## Макросы

К классу Form можно легко добавлять собственные методы; они называются "макросами". Вот как это работает. Сперва зарегистрируйте макрос с нужным именем и функцией-замыканием.

#### Регистрация макроса для Form

	Form::macro('myField', function()
	{
		return '<input type="awesome">';
	});

Теперь вы можете вызвать макрос, используя его имя:

#### Вызов макроса

	echo Form::myField();


<a name="generating-urls"></a>
##Формирование URL

Урлы можно не только задавать явным образом, но и формировать исходя из имени роута назначения или названия экшна контроллера - см. [helpers](/docs/{{version}}/helpers#urls).
